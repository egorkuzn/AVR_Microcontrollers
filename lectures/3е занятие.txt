.CSEG

LDI R16, Low(RAMEND)
OUT SPL, R16

LDI R16, High(RAMEND)
OUT SPH, R16

RAMEND - конец ОЗУ


Система тактирования.

Делится на внешнюю и внутреннюю. 
При пониженном питании
При пониженной частоте
При внутреннем RC/ Внутреннем калиброванном RC генератора

От этого тактирования запитывается тактирование других блоков. 
Таймеры, счётчики, приборы. Приразных систестемах тактирования сигнал может быть поделён. 
Мы делаем с фиксированной системой тактирования. Но иногда требуется такт, что высокое тактирование.
Иногда низкое. Например, при исследованиях нужен выше. Тогда быстрее считать больше.

 Высокая частота:
  _  
_| |_

Низкая частота:
  ____
_|    |_

Для таймера счётчика частота выставляется своими делителями. Это, например, позволяет ядру процессора работать быстрее.
Настройки частоты задаются регистрами: (Fuze bites)
При загрузке прошивки програмируются. 9й размер документации.
Есть СУД биты. Оценку должен дать разработкичик печатной платы (схемотехник). 
ЗАЧЕМ?? Ну например, батарейное питание устройства. Вы включаете, происзодит бросок потребления, накопитель работает. Если питание нестабильное, 
то будет чудить, нестабильно работать хранитель. Должен сказать разработчик устройства сколько нужно, или сами в силу свое опытаа.
Бывает делают так. 29 ножка (RESET/Сброс).

Эти FUZE биты позволяют вам настроить систему тактирования. Схемотехник задаёт начальные условия тактирания, а мы редактируем. Есть делитель аппаратный при необходимости. 
Его значения от 1 до 256. Можем сами поделить на 256 и вот вам частота. В практите было ещё внутренне тактирование. 

homes-smart.ru/fusecalc
http://yourdevice.net/proekty/avrdude-prog

Когда дойдем до реальных утсройств - понадобится. Пока для общего развития. У fuze бита - 1 стёрто, 0 - заполнено. Сначала читаем, потом стираем. А то можно стереть то что не 
хотели. 

AVR - AVRDUDE_PROG - там же настраиваем прошивку, безопасность. Если ошибся - то все. Приходится перепаивать. Иногда можно fuse bit'ов починить, но это оч сложно. 
Не нужно торопиться. 

Все 1 соответствуют первому режиму. Частота должна быть выбрана максимальная. 


На лабе: настройка EUCRA - настройка внешних прерываний. Мы рассматриуваем INT0 INT1. EIMSK, EIFR. Если устанавливается прирывание, то устанавливается бит. Что-то там про маску.
EICRA - настройка включения, маска.

Порты ввода/вывода. Три порта: port C, B, D. Обмен внешней информацией, переключение внешних устройств (транзиторы, дисплеи). На лабе с эти быдем работать. 


Вычтавление конретног окода у порта ввода вывода:

* PORTB (I/O)
* DDRB (направление: задаем либо на чтение, либо на запись)
* PINB (состояние, того что находится у нас физически. Доступен только для чтения)

ldi r16.(1 << PB7) 

Таймер-счётчик. 
8-битный, ШИМ. (подробнее рассмотрим на следующем занятии). Мы можем выходной импульстр из микроконтроллера делать ... менять скважность, длительность импульса. Расстояние мду импульсами.
Можем уменьшить мерцание светодлилола. Регилировка чатсоты вращения двигателя. 

https://web.archive.org/web/20191218080501/https://easyelectronics.ru/avr-uchebnyj-kurs-programmirovanie-na-si-chast-3.html


Пример для 1 секунды. 
* не равно ли 60 значение в регистре
* инкрементируем на 1 если не равно
Т.е. инкрементируем и проверяем на переполнение. В зависимоости от задач выбираем режим. Для задач ожидания - максимальное. Для проверки/замеров - минимальное.
Есть регистр TCNTn. В текущей задаче потребуется только флаги, а потом уже тот. Есть 16 битный, если 32 битный. Сразу считать старшую/младшую. Если сразу не прочитать - фигня.
OCnA/B Есть с выводом, есть без (снова зависит от задачи). От режима нужно идти и рассматривать его работу. Рассмотрим TCCR0B/TCCR0A. В первом есть младшие биты 
отвечающие за частоту тактирования. Либо от внешненего. OCR0A/B - регистры сравнения. TIMSK0 - прерывания маски. Прерывание флаги TIFR0.


1) Скелет очистки памяти.
2) Прерывание по внешнему
3) Прерывание по переполнению таймера счётчика. В область памяти мы должны записать.